# 워크플로우의 이름을 지정합니다. GitHub Actions 탭에서 이 이름으로 표시됩니다.
name: Deploy to Dev Server

# 워크플로우가 언제 실행될지를 정의하는 '트리거' 설정입니다.
on:
  # 'pull_request' 이벤트가 발생했을 때 이 워크플로우를 실행합니다.
  pull_request:
    # 'develop' 브랜치를 대상으로 하는 Pull Request에만 이 워크플로우를 적용합니다.
    branches: [ develop ]
    # Pull Request가 'closed'(닫혔을 때) 상태일 때만 실행합니다.
    types: [ closed ]

# 워크플로우에 포함될 작업(Job)들의 묶음입니다.
jobs:
  # 'deploy'라는 이름의 작업을 정의합니다. 이 작업은 하나의 가상 머신에서 실행됩니다.
  deploy:
    # ❗️ 이 작업의 실행 조건을 명시합니다.
    # Pull Request가 'merged'(병합)된 상태로 닫혔을 경우에만 아래 단계를 실행합니다.
    # (단순히 닫기만 한 PR에서는 배포가 실행되지 않습니다.)
    if: github.event.pull_request.merged == true

    # 이 작업이 실행될 가상 환경을 지정합니다. (최신 버전의 우분투 리눅스)
    runs-on: ubuntu-latest

    # 이 작업에서 순서대로 실행될 단계(Step)들입니다.
    steps:
      # 1. 코드 체크아웃
      # 리포지토리의 소스 코드를 가상 환경으로 내려받습니다. Docker 빌드 등에 필요합니다.
      - name: Checkout code
        uses: actions/checkout@v3

      # 2. GitHub Container Registry(GHCR)에 로그인
      # Docker 이미지를 빌드한 후 푸시할 수 있도록 GHCR에 인증하는 단계입니다.
      # GITHUB_TOKEN은 GitHub에서 자동으로 발급해주는 임시 비밀번호입니다.
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }} # 작업을 실행한 사용자 이름
          password: ${{ secrets.GITHUB_TOKEN }} # 자동으로 생성되는 토큰

      # 3. GitHub 조직/사용자 이름을 소문자로 변환
      # Docker 이미지 이름은 소문자만 허용하기 때문에, 대문자가 포함된 조직 이름을
      # 강제로 소문자로 바꿔주는 단계입니다.
      - name: Convert owner name to lowercase
        id: string_utils # 이 단계의 결과를 나중에 참조하기 위한 ID
        uses: ASzc/change-string-case-action@v6
        with:
          string: ${{ github.repository_owner }} # 리포지토리 소유자 이름 (예: SEMINAR2025-CUK)

      # 4. Docker 이미지 빌드 및 GHCR에 푸시
      # 프로젝트의 Dockerfile을 사용하여 애플리케이션 이미지를 빌드하고,
      # 위에서 로그인한 GHCR에 푸시하여 저장합니다.
      - name: Build and Push Docker image
        uses: docker/build-push-action@v5
        with:
          context: . # Dockerfile이 있는 위치 (프로젝트 루트)
          push: true # 빌드 후 이미지를 푸시할지 여부
          # 이미지 태그(이름) 설정. 위에서 변환한 소문자 이름을 사용합니다.
          tags: ghcr.io/${{ steps.string_utils.outputs.lowercase }}/gyeonggi-partners:dev

      # 5. EC2 서버에 docker-compose.dev.yml 파일 복사
      # 배포에 필요한 docker-compose 파일을 EC2 서버의 지정된 경로로 전송합니다.
      # 이 파일을 기준으로 서버에서 컨테이너를 실행하게 됩니다.
      - name: Copy docker-compose file to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }} # GitHub Secrets에 저장된 서버 주소
          username: ubuntu # EC2 접속 계정
          key: ${{ secrets.EC2_SSH_KEY }} # EC2 접속용 Private Key
          source: "docker-compose.dev.yml" # 리포지토리에 있는 원본 파일
          target: "~/gyeonggi_partners" # 서버에 복사될 위치

      # 6. EC2 서버에 접속하여 배포 스크립트 실행
      # SSH로 EC2 서버에 원격 접속하여, 애플리케이션을 실행시키는 명령어들을 순차적으로 실행합니다.
      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          # EC2 서버에서 실행될 스크립트 내용
          script: |
            # 프로젝트 디렉토리로 이동합니다.
            cd ~/gyeonggi_partners
            
            # EC2 서버가 GHCR에서 private 이미지를 내려받을 수 있도록 로그인합니다.
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # docker-compose.yml 파일에 정의된 이미지의 최신 버전을 내려받습니다.
            docker-compose -f docker-compose.dev.yml pull
            
            # 컨테이너를 최신 이미지로 다시 시작합니다. --force-recreate는 컨테이너를 강제로 재생성하여 변경사항을 확실히 반영합니다.
            docker-compose -f docker-compose.dev.yml up -d --force-recreate
            
            # 사용되지 않는 오래된 Docker 이미지를 삭제하여 서버 용량을 확보합니다.
            docker image prune -f